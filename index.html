// --- HEX PATCHER (SMART SLICE EDITION) ---
function patchHex(hexString, payloadData) {
  // Use a temporary full buffer for parsing
  const fullBuffer = new Uint8Array(8192).fill(0xFF); 
  let maxAddress = 0;

  const lines = hexString.split('\n');
  for (let line of lines) {
    line = line.trim();
    if (line[0] !== ':') continue;
    const len = parseInt(line.substr(1, 2), 16);
    const addr = parseInt(line.substr(3, 4), 16);
    const type = parseInt(line.substr(7, 2), 16);
    
    if (type === 0) { 
      for (let i = 0; i < len; i++) { 
        fullBuffer[addr + i] = parseInt(line.substr(9 + i * 2, 2), 16); 
      }
      // Track the highest byte written by the base firmware
      if (addr + len > maxAddress) maxAddress = addr + len;
    }
  }

  // Find Header
  let magicIdx = -1;
  for (let i = 0; i < fullBuffer.length - 4; i++) {
    if (fullBuffer[i]===0xCA && fullBuffer[i+1]===0xFE && fullBuffer[i+2]===0xBA && fullBuffer[i+3]===0xBE) {
      magicIdx = i; break;
    }
  }
  
  if (magicIdx === -1) throw new Error("TEMPLATE INVALID: MAGIC HEADER NOT FOUND");
  logMsg(`[SURGERY] Base Firmware Size: ${maxAddress} bytes`, 'debug');
  logMsg(`[SURGERY] Magic Header at: 0x${magicIdx.toString(16).toUpperCase()}`, 'debug');

  // Inject Payloads
  let currentOffset = 10;
  function inject(payload, label, offH_idx, offL_idx) {
    // Pointer Update
    fullBuffer[magicIdx + offH_idx] = (currentOffset >> 8) & 0xFF;
    fullBuffer[magicIdx + offL_idx] = (currentOffset) & 0xFF;
    
    if (payload.length <= 1) return;
    
    // Safety check relative to buffer
    if (magicIdx + currentOffset + payload.length >= fullBuffer.length) throw new Error("PAYLOAD TOO LARGE");

    let writePtr = magicIdx + currentOffset;
    for(let b of payload) {
        fullBuffer[writePtr++] = b;
    }
    
    // Update Max Address if payload extends beyond current firmware size
    if (writePtr > maxAddress) maxAddress = writePtr;
    
    currentOffset += payload.length;
  }

  inject(payloadData.c1, "Chamber 1", 4, 5);
  inject(payloadData.c2, "Chamber 2", 6, 7);
  inject(payloadData.c3, "Chamber 3", 8, 9);
  
  // --- CRITICAL: TRIM BUFFER ---
  // We only return the buffer up to the last used byte.
  // We align it to 64-byte pages (MicroNucleus Page Size) to be clean.
  const alignedSize = Math.ceil(maxAddress / 64) * 64;
  logMsg(`[SURGERY] Final Image Size: ${alignedSize} bytes (Safety Trim)`, 'success');
  
  return fullBuffer.slice(0, alignedSize);
}

// ... rest of app logic ...
