<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>BADUSB ROULETTE [SAFETY LOCK]</title>
  
  <script src="firmware/micronucleus.js"></script>

  <style>
    :root {
      --bg-color: #050505;
      --term-green: #00ff41;
      --term-dim: #008f11;
      --alert-red: #ff0000;
      --panel-bg: #0a0a0a;
      --border-color: #333;
    }

    body {
      background-color: var(--bg-color);
      color: var(--term-green);
      font-family: 'Consolas', 'Monaco', monospace;
      margin: 0; padding: 0;
      display: flex; flex-direction: column; align-items: center;
      min-height: 100vh; overflow-x: hidden;
    }

    header {
      width: 100%; padding: 20px 0; text-align: center;
      border-bottom: 1px solid var(--term-dim); margin-bottom: 20px;
      position: relative;
    }

    h1 { font-size: 2rem; letter-spacing: 5px; margin: 0; text-transform: uppercase; }

    #driverStatus {
      position: absolute; top: 10px; right: 10px;
      font-size: 0.7rem; border: 1px solid var(--term-dim);
      padding: 5px; color: var(--term-dim);
    }
    .status-ok { color: var(--term-green) !important; border-color: var(--term-green) !important; }
    .status-err { color: var(--alert-red) !important; border-color: var(--alert-red) !important; }

    #manualDriverZone {
      display: none; background: rgba(50, 0, 0, 0.3);
      border: 1px dashed var(--alert-red); padding: 10px;
      margin-bottom: 20px; text-align: center; width: 90%; max-width: 600px;
    }
    .driver-btn {
      background: var(--alert-red); color: #000; border: none;
      padding: 5px 10px; cursor: pointer; font-weight: bold;
      font-family: inherit; margin-top: 5px;
    }

    .os-warning {
      display: none; width: 95%; max-width: 800px;
      border: 1px solid var(--alert-red); background: rgba(50, 0, 0, 0.8);
      margin-bottom: 20px; padding: 15px; font-size: 0.9rem;
      color: #fff; text-align: left;
    }
    .os-warning h3 { 
      margin: 0 0 10px 0; color: var(--alert-red); 
      border-bottom: 1px solid var(--alert-red); padding-bottom: 5px; 
    }
    .code-block {
      background: #000; border: 1px solid #666; padding: 10px;
      margin-top: 10px; font-family: 'Consolas', monospace;
      font-size: 0.8rem; color: #ccc; white-space: pre-wrap; word-break: break-all;
    }

    .armory-controls {
      display: flex; gap: 20px; margin-bottom: 20px;
      align-items: center; flex-wrap: wrap; justify-content: center;
      font-size: 0.9rem;
    }

    select, .file-upload, button {
      background: #000; color: var(--term-green);
      border: 1px solid #333; padding: 8px; font-family: inherit; cursor: pointer;
    }
    .file-upload { color: #888; border-style: dashed; }
    .file-upload:hover { border-color: var(--term-green); color: var(--term-green); }
    input[type="file"] { display: none; }
    
    button:hover { background: var(--term-green); color: #000; }
    
    #burnBtn {
      border: 2px solid var(--term-green); padding: 15px 40px;
      font-size: 1.2rem; letter-spacing: 2px;
      text-transform: uppercase;
    }
    
    #genInoBtn {
      border: 1px dashed #666; color: #666; font-size: 0.8rem;
    }
    #genInoBtn:hover { border-color: var(--term-green); color: var(--term-green); background: #000; }

    .chamber-grid {
      display: flex; gap: 15px; width: 95%; max-width: 1600px;
      flex: 1; margin-bottom: 30px;
    }

    .chamber {
      flex: 1; background: var(--panel-bg);
      border: 1px solid var(--border-color);
      display: flex; flex-direction: column;
    }

    .chamber-header {
      background: #111; border-bottom: 1px solid #333;
      padding: 8px; display: flex;
      justify-content: space-between; align-items: center;
      font-size: 0.8rem;
    }
    
    .mutation-select {
        background: #000; color: #666;
        border: 1px solid #333; font-size: 0.7rem;
    }

    textarea {
      flex: 1; background: #000; color: #ccc;
      border: none; padding: 10px; resize: none;
      font-family: 'Consolas', monospace; font-size: 13px;
      line-height: 1.4; outline: none; min-height: 300px;
    }

    .trigger-zone { 
      width: 100%; text-align: center; padding-bottom: 20px;
      display: flex; flex-direction: column; align-items: center; gap: 10px;
    }

    .console-wrapper {
      width: 95%; max-width: 1600px;
      background: #000; border: 1px solid #333; margin-bottom: 40px;
    }
    .console-header {
      background: #111; border-bottom: 1px solid #333;
      padding: 5px 10px; font-size: 0.75rem; color: #666;
    }
    #log {
      height: 300px; overflow-y: scroll; padding: 10px;
      font-family: 'Consolas', monospace; font-size: 0.85rem;
      color: #aaa; white-space: pre-wrap;
    }
    .log-line { border-bottom: 1px solid #111; padding: 2px 0; }
    .log-err { color: var(--alert-red); }
    .log-ok { color: var(--term-green); }
    .log-debug { color: #555; }
  </style>

  <script>
    function onDriverLoad() {
      if (typeof Micronucleus !== 'undefined') {
        document.getElementById('driverStatus').innerText = "DRIVER: ACTIVE";
        document.getElementById('driverStatus').className = "status-ok";
        document.getElementById('manualDriverZone').style.display = 'none';
        console.log("Micronucleus Loaded.");
      }
    }
    function onDriverError() {
      document.getElementById('driverStatus').innerText = "DRIVER: MISSING";
      document.getElementById('driverStatus').className = "status-err";
      document.getElementById('manualDriverZone').style.display = 'block';
    }
  </script>
  
  <script src="firmware/micronucleus.js" onload="onDriverLoad()" onerror="onDriverError()"></script>
</head>
<body>

  <header>
    <h1>BadUSB Roulette</h1>
    <div class="subtitle">/// UNIFIED PAYLOAD SYSTEM ///</div>
    <div id="driverStatus">DRIVER: CHECKING...</div>
  </header>

  <div id="manualDriverZone">
    <div style="color: var(--alert-red); font-weight: bold; margin-bottom: 5px;">
      ⚠️ AUTOMATIC DRIVER LOAD FAILED
    </div>
    <label class="driver-btn">
      LOAD DRIVER FROM DISK
      <input type="file" id="manualDriverFile" accept=".js" style="display:none;">
    </label>
  </div>

  <div id="winWarning" class="os-warning">
    <h3>/// WINDOWS DETECTED ///</h3>
    CRITICAL: WebUSB requires the <strong>WinUSB</strong> driver.
    <br><br>
    1. Download <a href="https://zadig.akeo.ie/" target="_blank">Zadig</a>.<br>
    2. Options > 'List All Devices'.<br>
    3. Select 'Digispark Bootloader' -> Replace with <strong>WinUSB</strong>.
  </div>

  <div id="linuxWarning" class="os-warning">
    <h3>/// LINUX PERMISSION ERROR ///</h3>
    <strong>ACCESS DENIED:</strong> Run this, then unplug/replug:
    <div class="code-block">echo 'SUBSYSTEM=="usb", ATTR{idVendor}=="16d0", ATTR{idProduct}=="0753", MODE="0666", GROUP="plugdev"' | sudo tee /etc/udev/rules.d/99-digispark.rules && sudo udevadm control --reload-rules && sudo udevadm trigger</div>
  </div>

  <div class="armory-controls">
    <label>TARGET:</label>
    <select id="hwModel">
      <option value="roulette_single.hex">UNIVERSAL SINGLE (Pin 0+1)</option>
      <option value="roulette_dual.hex">DUAL LED (Green P0, Red P1)</option>
    </select>
    
    <label class="file-upload">
      [ MANUAL LOAD .HEX ]
      <input type="file" id="customHex" accept=".hex">
    </label>
  </div>

  <div class="chamber-grid">
    <div class="chamber">
      <div class="chamber-header">
        C1
        <select class="mutation-select" onchange="mutate(this, 'c1')">
          <option value="" disabled selected>MUTATE</option>
          <option value="WIN">WIN</option>
          <option value="MAC">MAC</option>
          <option value="LINUX">LINUX</option>
        </select>
      </div>
      <textarea id="c1" placeholder="// CHAMBER 1 PAYLOAD"></textarea>
    </div>
    <div class="chamber">
      <div class="chamber-header">
        C2
        <select class="mutation-select" onchange="mutate(this, 'c2')">
          <option value="" disabled selected>MUTATE</option>
          <option value="WIN">WIN</option>
          <option value="MAC">MAC</option>
          <option value="LINUX">LINUX</option>
        </select>
      </div>
      <textarea id="c2" placeholder="// CHAMBER 2 PAYLOAD"></textarea>
    </div>
    <div class="chamber">
      <div class="chamber-header">
        C3
        <select class="mutation-select" onchange="mutate(this, 'c3')">
          <option value="" disabled selected>MUTATE</option>
          <option value="WIN">WIN</option>
          <option value="MAC">MAC</option>
          <option value="LINUX">LINUX</option>
        </select>
      </div>
      <textarea id="c3" placeholder="// CHAMBER 3 PAYLOAD"></textarea>
    </div>
  </div>

  <div class="trigger-zone">
    <button id="burnBtn">FLASH FIRMWARE (WEBUSB)</button>
    <button id="genInoBtn">GENERATE .INO [ESCAPE POD]</button>
  </div>

  <div class="console-wrapper">
    <div class="console-header">/// SERIAL LOG ///</div>
    <div id="log"></div>
  </div>

<script>
// --- EMBEDDED TEMPLATES (ESCAPE POD) ---
const TEMPLATE_CFG = `
#ifndef ROULETTE_CFG_H
#define ROULETTE_CFG_H

// --- HARDWARE CONFIG ---
// DUAL_LED_MODE 0 = Universal Single (Blinks P0 & P1)
// DUAL_LED_MODE 1 = Dual Mode (Green P0, Red P1)
#define DUAL_LED_MODE 0 

// --- PIN MAPPING ---
// In Universal Mode (0), these defines are ignored by the wrapper.
// In Dual Mode (1), specific pins are used.
#define PIN_GREEN  0
#define PIN_RED    1

// --- GAME PHYSICS ---
#define TOTAL_CHAMBERS 3
#define SAFE_WINDOW 3000

#endif
`;

const TEMPLATE_INO = `
/*
   PROJECT: BadUSB Revolver (Universal Edition)
   HARDWARE: ATtiny85 (Digispark Rev A & B Compatible)
 */

#include <avr/eeprom.h>
#include "DigiKeyboard.h"
#include "roulette_cfg.h"

// ==========================================
//      VIRTUAL MACHINE DEFINITIONS
// ==========================================
#define OP_END      0x00
#define OP_DELAY    0x01
#define OP_KEY      0x02
#define OP_PRINT    0x03
#define OP_PRINTLN  0x04

// RESERVE 1KB FOR PAYLOADS
// __attribute__((used)) prevents the linker from stripping this symbol
const uint8_t PAYLOAD_STORAGE[1024] PROGMEM __attribute__((used)) = {
  0xCA, 0xFE, 0xBA, 0xBE, 
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00 
};

// ==========================================
//      FORWARD DECLARATIONS
// ==========================================
void set_led(uint8_t state);
bool has_payload(byte chamber);
void run_vm(uint16_t ptr);
void signal_flash();
void signal_arm();
void signal_fire();
void signal_done();

// ==========================================
//      HARDWARE ABSTRACTION
// ==========================================
void set_led(uint8_t state) {
  #if DUAL_LED_MODE == 1
    // Dual Mode Failsafe: Use RED PIN 1 for generic blinks if strictly requested
    digitalWrite(PIN_RED, state);
  #else
    // Single/Universal Mode: Blast BOTH pins.
    digitalWrite(0, state);
    digitalWrite(1, state);
  #endif
}

// ==========================================
//      LOGIC ENGINE
// ==========================================

bool has_payload(byte chamber) {
  if (chamber >= TOTAL_CHAMBERS) return false;
  uint16_t offset_loc = 4 + (chamber * 2);
  uint8_t off_h = pgm_read_byte(&PAYLOAD_STORAGE[offset_loc]);
  uint8_t off_l = pgm_read_byte(&PAYLOAD_STORAGE[offset_loc + 1]);
  uint16_t ptr = (off_h << 8) | off_l;
  // Pointer must be non-zero and within the storage limit
  return (ptr > 0 && ptr < 1024);
}

void setup() {
  // 1. PANIC BLINK (Hardware Agnostic)
  pinMode(0, OUTPUT);
  pinMode(1, OUTPUT);
  for(int k=0; k<5; k++) {
    digitalWrite(0, HIGH);
    digitalWrite(1, HIGH);
    DigiKeyboard.delay(100);
    digitalWrite(0, LOW);
    digitalWrite(1, LOW);
    DigiKeyboard.delay(100);
  }

  // 2. STATE RECOVERY
  // Pin modes are already OUTPUT from panic blink.
  // Ensure off state.
  digitalWrite(0, LOW);
  digitalWrite(1, LOW);

  // 3. RUSSIAN ROULETTE LOGIC
  byte mode = eeprom_read_byte((const uint8_t*)0);
  if (mode >= TOTAL_CHAMBERS) mode = 0;

  // A. Stale Memory Check (Skip empties)
  // Logic: Scan forward until we find a payload or loop back to start
  byte check = mode;
  bool found = false;
  for (int i = 0; i < TOTAL_CHAMBERS; i++) {
    if (has_payload(check)) {
        found = true;
        mode = check;
        break;
    }
    check = (check + 1) % TOTAL_CHAMBERS;
  }

  // FAILSAFE: If ALL chambers are empty, die SOS.
  if (!found) {
    while(1) {
      set_led(HIGH);
      DigiKeyboard.delay(100);
      set_led(LOW);
      DigiKeyboard.delay(100);
    }
  }

  // B. Calculate & Write NEXT Step Immediately
  // If user unplugs during ARMING, this value persists.
  byte next = (mode + 1) % TOTAL_CHAMBERS;
  // Ensure the next one we queue is also valid (so we don't boot into a dead chamber)
  for (int i = 0; i < TOTAL_CHAMBERS; i++) {
    if (has_payload(next)) break;
    next = (next + 1) % TOTAL_CHAMBERS;
  }
  eeprom_update_byte((uint8_t*)0, next);

  // 4. IDENTIFICATION PHASE
  DigiKeyboard.delay(1000);
  for (int i = 0; i <= mode; i++) {
    signal_flash();
    DigiKeyboard.delay(300);
  }

  // 5. ARMING PHASE
  signal_arm(); 
  DigiKeyboard.delay(SAFE_WINDOW);

  // 6. FIRE PHASE
  signal_fire();
  // EXECUTE PAYLOAD
  uint16_t offset_loc = 4 + (mode * 2);
  uint8_t off_h = pgm_read_byte(&PAYLOAD_STORAGE[offset_loc]);
  uint8_t off_l = pgm_read_byte(&PAYLOAD_STORAGE[offset_loc + 1]);
  uint16_t payload_addr = (off_h << 8) | off_l;
  if (payload_addr > 0 && payload_addr < 1024) {
     run_vm(payload_addr);
  }

  // 7. COMPLETION PHASE
  signal_done();
  for (;;) {
    DigiKeyboard.delay(1000); // Keep USB alive
  } 
}

void loop() {}

// ==========================================
//      BYTECODE INTERPRETER
// ==========================================
void run_vm(uint16_t ptr) {
  while(true) {
    uint8_t opcode = pgm_read_byte(&PAYLOAD_STORAGE[ptr++]);
    
    // Safety: 0xFF is erased flash memory. Treat as end.
    if (opcode == OP_END || opcode == 0xFF) break;
    
    else if (opcode == OP_DELAY) {
      uint8_t h = pgm_read_byte(&PAYLOAD_STORAGE[ptr++]);
      uint8_t l = pgm_read_byte(&PAYLOAD_STORAGE[ptr++]);
      uint16_t t = (h << 8) | l;
      DigiKeyboard.delay(t);
    }
    
    else if (opcode == OP_KEY) {
      uint8_t mod = pgm_read_byte(&PAYLOAD_STORAGE[ptr++]);
      uint8_t key = pgm_read_byte(&PAYLOAD_STORAGE[ptr++]);
      DigiKeyboard.sendKeyStroke(key, mod);
    }
    
    else if (opcode == OP_PRINT || opcode == OP_PRINTLN) {
      uint8_t len = pgm_read_byte(&PAYLOAD_STORAGE[ptr++]);
      for (int i=0; i<len; i++) {
        char c = (char)pgm_read_byte(&PAYLOAD_STORAGE[ptr++]);
        DigiKeyboard.print(c);
      }
      if (opcode == OP_PRINTLN) DigiKeyboard.print("\\n");
    }
    
    // Safety Break (End of Storage)
    if (ptr >= 1024) break;
  }
  // CLEANUP: Ensure no keys are left stuck down
  DigiKeyboard.sendKeyStroke(0);
}

// ==========================================
//      SIGNALING HELPERS
// ==========================================

void signal_flash() {
  #if DUAL_LED_MODE == 1
    digitalWrite(PIN_GREEN, HIGH);
    DigiKeyboard.delay(200);
    digitalWrite(PIN_GREEN, LOW);
  #else
    set_led(HIGH);
    DigiKeyboard.delay(200);
    set_led(LOW);
  #endif
}

void signal_arm() {
  #if DUAL_LED_MODE == 1
    digitalWrite(PIN_RED, HIGH);
  #else
    set_led(HIGH);
  #endif
}

void signal_fire() {
  #if DUAL_LED_MODE == 1
    digitalWrite(PIN_RED, LOW);
  #else
    set_led(LOW);
  #endif
}

void signal_done() {
  #if DUAL_LED_MODE == 1
    digitalWrite(PIN_GREEN, HIGH);
  #else
    for(int i=0; i<5; i++){
       set_led(HIGH);
       DigiKeyboard.delay(50);
       set_led(LOW);
       DigiKeyboard.delay(50);
    }
  #endif
}
`;

// --- HANDLERS ---
document.getElementById('manualDriverFile').addEventListener('change', (e) => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = function(evt) {
    const script = document.createElement('script');
    script.text = evt.target.result;
    document.head.appendChild(script);
    setTimeout(() => { if (typeof Micronucleus !== 'undefined') onDriverLoad(); }, 100);
  };
  reader.readAsText(file);
});

function mutate(selectEl, targetId) {
  const ta = document.getElementById(targetId);
  const mode = selectEl.value;
  if(mode === 'WIN') ta.value = "// WINDOWS PAYLOAD\nDELAY 1000\nGUI r\nDELAY 200\nSTRING notepad\nENTER\nDELAY 500\nSTRING FATAL ERROR\nENTER";
  else if (mode === 'MAC') ta.value = "// MAC PAYLOAD\nDELAY 1000\nGUI SPACE\nDELAY 200\nSTRING Terminal\nENTER\nDELAY 500\nSTRING echo 'PANIC'\nENTER";
  else if (mode === 'LINUX') ta.value = "// LINUX PAYLOAD\nDELAY 1000\nGUI\nDELAY 200\nSTRING terminal\nENTER\nDELAY 500\nSTRING echo 'RM -RF /'\nENTER";
}

function logMsg(msg, type='normal') {
  const logEl = document.getElementById('log');
  const line = document.createElement('div');
  line.className = 'log-line ' + (type === 'error' ? 'log-err' : type === 'success' ? 'log-ok' : 'log-debug');
  line.innerText = `[${new Date().toLocaleTimeString('en-US',{hour12:false})}] ${msg}`;
  logEl.appendChild(line);
  logEl.scrollTop = logEl.scrollHeight;
}

// --- COMPILER ---
const KEY_MAP = {
  'ENTER':0x28, 'ESC':0x29, 'BACKSPACE':0x2A, 'TAB':0x2B, 'SPACE':0x2C, 'MINUS':0x2D, 
  'EQUAL':0x2E, 'LEFT_BRACE':0x2F, 'RIGHT_BRACE':0x30, 'BACKSLASH':0x31, 'SEMICOLON':0x33, 
  'QUOTE':0x34, 'GRAVE':0x35, 'COMMA':0x36, 'PERIOD':0x37, 'SLASH':0x38, 'CAPS_LOCK':0x39, 
  'F1':0x3A, 'F2':0x3B, 'F3':0x3C, 'F4':0x3D, 'F5':0x3E, 'F6':0x3F, 'F7':0x40, 'F8':0x41, 
  'F9':0x42, 'F10':0x43, 'F11':0x44, 'F12':0x45, 'PRINTSCREEN':0x46, 'SCROLL_LOCK':0x47, 
  'PAUSE':0x48, 'INSERT':0x49, 'HOME':0x4A, 'PAGE_UP':0x4B, 'DELETE':0x4C, 'END':0x4D, 
  'PAGE_DOWN':0x4E, 'RIGHT':0x4F, 'LEFT':0x50, 'DOWN':0x51, 'UP':0x52, 'GUI':0xE3, 'WINDOWS':0xE3
};

const MOD_BITMASKS = { 'CTRL': 0x01, 'SHIFT': 0x02, 'ALT': 0x04, 'GUI': 0x08, 'COMMAND': 0x08 };

function compileDucky(script) {
  const bytes = [];
  const lines = script.split('\n');
  let lastCmd = null;
  let defaultDelay = 0;

  for (let line of lines) {
    line = line.trim();
    if (!line || line.startsWith("REM") || line.startsWith("//")) continue;
    
    // Inject Default Delay if set (before each command except DELAY/DEFAULT_DELAY)
    const isControl = line.startsWith("DELAY") || line.startsWith("DEFAULT_DELAY") || line.startsWith("DEFAULTDELAY");
    if (defaultDelay > 0 && !isControl) {
        bytes.push(0x01, (defaultDelay >> 8) & 0xFF, defaultDelay & 0xFF);
    }

    const parts = line.split(' ');
    const cmd = parts[0].toUpperCase();
    const args = parts.slice(1).join(' ');
    let currentCmdBytes = [];

    // 1. REPEAT
    if (cmd === 'REPEAT') {
        const count = parseInt(args);
        if (lastCmd && !isNaN(count)) {
            for(let k=0; k<count; k++) {
                bytes.push(...lastCmd);
            }
        }
        continue; // Don't update lastCmd
    }
    
    // 2. DELAY
    else if (cmd === 'DELAY') {
      const ms = parseInt(args);
      currentCmdBytes = [0x01, (ms >> 8) & 0xFF, ms & 0xFF];
    }
    
    // 3. DEFAULT_DELAY
    else if (cmd === 'DEFAULT_DELAY' || cmd === 'DEFAULTDELAY') {
        defaultDelay = parseInt(args);
        continue;
    }

    // 4. STRING
    else if (cmd === 'STRING') {
      for (let i = 0; i < args.length; i += 255) {
        const chunk = args.substring(i, Math.min(i + 255, args.length));
        currentCmdBytes.push(0x03, chunk.length); 
        for (let c = 0; c < chunk.length; c++) currentCmdBytes.push(chunk.charCodeAt(c));
      }
    } 
    // 5. MODIFIER + KEY
    else if (MOD_BITMASKS[cmd] && parts.length > 1) {
      const keyStr = parts[1].toUpperCase();
      let keyByte = 0;
      if (keyStr.length === 1) keyByte = getAsciiKey(keyStr); 
      if (keyByte === 0 && KEY_MAP[keyStr]) keyByte = KEY_MAP[keyStr]; 
      
      if (keyByte > 0) currentCmdBytes = [0x02, MOD_BITMASKS[cmd], keyByte];
    }
    // 6. SINGLE KEY
    else if (KEY_MAP[cmd]) { 
      currentCmdBytes = [0x02, 0x00, KEY_MAP[cmd]]; 
    }

    if (currentCmdBytes.length > 0) {
        bytes.push(...currentCmdBytes);
        lastCmd = currentCmdBytes;
    }
  }
  bytes.push(0x00); // OP_END
  return bytes;
}

function getAsciiKey(char) {
    const code = char.toLowerCase().charCodeAt(0);
    if (code >= 97 && code <= 122) return code - 93; 
    if (code >= 49 && code <= 57) return code - 19; 
    if (code === 48) return 39; 
    return 0;
}

// --- HEX PATCHER ---
function patchHex(hexString, payloadData) {
  const fullBuffer = new Uint8Array(8192).fill(0xFF); 
  let maxAddress = 0;

  // Parse Hex
  const lines = hexString.split('\n');
  for (let line of lines) {
    line = line.trim();
    if (line[0] !== ':') continue;
    const len = parseInt(line.substr(1, 2), 16);
    const addr = parseInt(line.substr(3, 4), 16);
    const type = parseInt(line.substr(7, 2), 16);
    if (type === 0) { 
      for (let i = 0; i < len; i++) { 
        fullBuffer[addr + i] = parseInt(line.substr(9 + i * 2, 2), 16); 
      }
      if (addr + len > maxAddress) maxAddress = addr + len;
    }
  }

  // Find Header (CAFEBABE)
  let magicIdx = -1;
  for (let i = 0; i < maxAddress; i++) {
    if (fullBuffer[i]===0xCA && fullBuffer[i+1]===0xFE && fullBuffer[i+2]===0xBA && fullBuffer[i+3]===0xBE) {
      magicIdx = i; break;
    }
  }
  if (magicIdx === -1) throw new Error("CRITICAL: Hex Header 'CAFEBABE' Missing. Firmware Incompatible.");

  let currentOffset = 10;
  function inject(payload, offH_idx, offL_idx) {
    if (payload.length <= 1) {
        fullBuffer[magicIdx + offH_idx] = 0x00;
        fullBuffer[magicIdx + offL_idx] = 0x00;
        return;
    }
    fullBuffer[magicIdx + offH_idx] = (currentOffset >> 8) & 0xFF;
    fullBuffer[magicIdx + offL_idx] = (currentOffset) & 0xFF;
    
    if (currentOffset + payload.length > 1024) throw new Error("PAYLOAD OVERFLOW: 1KB LIMIT EXCEEDED");
    
    let writePtr = magicIdx + currentOffset;
    for(let b of payload) fullBuffer[writePtr++] = b;
    if (writePtr > maxAddress) maxAddress = writePtr;
    
    currentOffset += payload.length;
  }

  inject(payloadData.c1, 4, 5);
  inject(payloadData.c2, 6, 7);
  inject(payloadData.c3, 8, 9);
  
  return fullBuffer.slice(0, Math.ceil(maxAddress / 64) * 64);
}

// --- FLASHER ---
document.getElementById('burnBtn').addEventListener('click', async () => {
  const hw = document.getElementById('hwModel').value;
  try {
    if (!navigator.usb) throw new Error("WebUSB not supported");
    if (typeof Micronucleus === 'undefined') throw new Error("Driver not loaded.");
    
    const payloads = {
      c1: compileDucky(document.getElementById('c1').value),
      c2: compileDucky(document.getElementById('c2').value),
      c3: compileDucky(document.getElementById('c3').value)
    };
    
    const response = await fetch(`firmware/${hw}`);
    if(!response.ok) throw new Error("Hex file missing");
    const hexText = await response.text();
    
    const firmBuffer = patchHex(hexText, payloads);
    logMsg(`[SYS] Flashing ${firmBuffer.length} bytes...`, 'warn');
    
    const device = await navigator.usb.requestDevice({ filters: [{ vendorId: 0x16d0, productId: 0x0753 }] });
    const client = new Micronucleus(device);
    await client.upload(firmBuffer);
    logMsg("/// DONE ///", 'success');
    
  } catch (e) {
    if (e.message.includes("Access denied") || e.message.includes("denied")) document.getElementById('linuxWarning').style.display = 'block';
    logMsg(e.message, 'error');
  }
});

// --- INO GENERATOR (ESCAPE POD) ---
document.getElementById('genInoBtn').addEventListener('click', () => {
  const hwValue = document.getElementById('hwModel').value;
  const isDual = hwValue.includes("dual");
  
  logMsg("[GEN] Compiling Source...", 'debug');
  
  try {
    let inoText = TEMPLATE_INO;
    let cfgText = TEMPLATE_CFG;
    
    // 2. Patch Config
    if (isDual) cfgText = cfgText.replace(/#define DUAL_LED_MODE .*/, "#define DUAL_LED_MODE 1");
    else cfgText = cfgText.replace(/#define DUAL_LED_MODE .*/, "#define DUAL_LED_MODE 0");
    
    inoText = inoText.replace('#include "roulette_cfg.h"', "// --- CONFIG INJECTED BY GENERATOR ---\n" + cfgText + "\n// -----------------------------------");
    
    // 3. Build Byte Array
    let t1 = document.getElementById('c1').value.trim();
    let t2 = document.getElementById('c2').value.trim();
    let t3 = document.getElementById('c3').value.trim();
    
    // SAFETY INJECTOR: If all are empty, inject a default blink script to prevent logic bricking
    if(t1 === "" && t2 === "" && t3 === "") {
        t1 = "DELAY 500\\nREPEAT 5\\nDELAY 100"; 
        logMsg("[WARN] No payloads detected. Injecting safety blink.", 'error');
    }
    
    const p1 = compileDucky(t1);
    const p2 = compileDucky(t2);
    const p3 = compileDucky(t3);
    
    const mem = new Uint8Array(1024).fill(0);
    // Header
    mem[0] = 0xCA; mem[1] = 0xFE; mem[2] = 0xBA; mem[3] = 0xBE;
    
    let cursor = 10;
    
    function writeP(payload, offH, offL) {
       if (payload.length <= 1) return; // Empty
       
       mem[offH] = (cursor >> 8) & 0xFF;
       mem[offL] = (cursor) & 0xFF;
       
       for(let b of payload) {
         if (cursor >= 1024) throw new Error("PAYLOAD OVERFLOW");
         mem[cursor++] = b;
       }
    }
    
    writeP(p1, 4, 5);
    writeP(p2, 6, 7);
    writeP(p3, 8, 9);
    
    // 4. Stringify Array
    let cArray = "{\n  ";
    for(let i=0; i<1024; i++) {
        cArray += "0x" + mem[i].toString(16).padStart(2,'0').toUpperCase();
        if(i < 1023) cArray += ", ";
        if((i+1) % 16 === 0) cArray += "\n  ";
    }
    cArray += "}";
    
    // 5. Inject into Source
    const startMarker = "const uint8_t PAYLOAD_STORAGE[1024] PROGMEM __attribute__((used)) =";
    const regex = /const uint8_t PAYLOAD_STORAGE\[1024\] PROGMEM __attribute__\(\(used\)\) = \{[\s\S]*?\};/;
    
    inoText = inoText.replace(regex, startMarker + " " + cArray + ";");
    
    // 6. Download
    const blob = new Blob([inoText], {type: "text/x-c++src"});
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = "BadUSB_Roulette_Recovery.ino";
    link.click();
    
    logMsg("[GEN] Recovery File Created.", 'success');

  } catch (e) {
    logMsg("GEN FAILED: " + e.message, 'error');
  }
});
</script>
</body>
</html>
